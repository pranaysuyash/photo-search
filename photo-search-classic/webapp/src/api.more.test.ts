import { describe, it, expect, vi } from 'vitest'
import { apiEditOps, apiUpscale, apiExport, apiBuildMetadata, apiGetMetadata, apiFacesBuild, apiFacesClusters, apiFacesName, apiGetSmart, apiSetSmart, apiDeleteSmart, apiResolveSmart, apiOpen, apiExif, apiSearchLike, apiGetCollections, apiSetCollection, apiDeleteCollection, apiWorkspaceList, apiWorkspaceAdd, apiWorkspaceRemove, apiSearchWorkspace } from './api'

const mockFetch = (data: any) => vi.spyOn(global, 'fetch' as any).mockResolvedValue({ ok: true, json: async () => data } as any)

describe('classic api (more)', () => {
  it('edit ops posts mapped fields', async () => {
    const spy = mockFetch({ out_path: '/out.jpg' })
    await apiEditOps('/d', '/a.jpg', { rotate: 90, flip: 'h', crop: { x: 1, y: 2, w: 3, h: 4 } })
    const [, init] = spy.mock.calls[0]
    expect(JSON.parse(init!.body)).toMatchObject({ rotate: 90, flip: 'h', crop: { x: 1, y: 2, w: 3, h: 4 } })
    spy.mockRestore()
  })

  it('upscale posts scale and engine', async () => {
    const spy = mockFetch({ out_path: '/out.jpg' })
    await apiUpscale('/d', '/a.jpg', 4, 'realesrgan')
    expect(JSON.parse(spy.mock.calls[0][1]!.body)).toMatchObject({ scale: 4, engine: 'realesrgan' })
    spy.mockRestore()
  })

  it('export posts paths and options', async () => {
    const spy = mockFetch({ ok: true, copied: 1, skipped: 0, errors: 0, dest: '/dest' })
    await apiExport('/d', ['/a.jpg'], '/dest', 'copy', true, false)
    const body = JSON.parse(spy.mock.calls[0][1]!.body)
    expect(body).toMatchObject({ dest: '/dest', strip_exif: true })
    spy.mockRestore()
  })

  it('metadata build/get', async () => {
    let spy = mockFetch({ updated: 1, cameras: [] })
    await apiBuildMetadata('/d', 'local', 'hf', 'oai')
    expect(String(spy.mock.calls[0][0])).toMatch(/metadata\/build$/)
    spy.mockRestore()
    spy = mockFetch({ cameras: [] })
    await apiGetMetadata('/d')
    expect(String(spy.mock.calls[0][0])).toMatch(/metadata\?dir=/)
    spy.mockRestore()
  })

  it('faces and smart collections', async () => {
    let spy = mockFetch({ updated: 1, faces: 10, clusters: 2 })
    await apiFacesBuild('/d', 'local')
    expect(String(spy.mock.calls[0][0])).toMatch(/faces\/build$/)
    spy.mockRestore()
    spy = mockFetch({ clusters: [] })
    await apiFacesClusters('/d')
    expect(String(spy.mock.calls[0][0])).toMatch(/faces\/clusters\?dir=/)
    spy.mockRestore()
    spy = mockFetch({ ok: true })
    await apiFacesName('/d', 'id', 'Alice')
    expect(String(spy.mock.calls[0][0])).toMatch(/faces\/name$/)
    spy.mockRestore()
    spy = mockFetch({ smart: {} })
    await apiGetSmart('/d')
    expect(String(spy.mock.calls[0][0])).toMatch(/smart_collections\?dir=/)
    spy.mockRestore()
    spy = mockFetch({ ok: true, smart: {} })
    await apiSetSmart('/d', 'Favs', {})
    expect(String(spy.mock.calls[0][0])).toMatch(/smart_collections$/)
    spy.mockRestore()
    spy = mockFetch({ ok: true, deleted: 'Favs' })
    await apiDeleteSmart('/d', 'Favs')
    expect(String(spy.mock.calls[0][0])).toMatch(/smart_collections\/delete$/)
    spy.mockRestore()
    spy = mockFetch({ search_id: 's', results: [] })
    await apiResolveSmart('/d', 'Favs', 'local', 24)
    expect(String(spy.mock.calls[0][0])).toMatch(/smart_collections\/resolve$/)
    spy.mockRestore()
  })

  it('open and exif', async () => {
    let spy = mockFetch({ ok: true })
    await apiOpen('/d', '/a.jpg')
    expect(String(spy.mock.calls[0][0])).toMatch(/\/open$/)
    spy.mockRestore()
    spy = mockFetch({ path: '/a.jpg', width: 0, height: 0, camera: null, date: null })
    await apiExif('/d', '/a.jpg')
    expect(String(spy.mock.calls[0][0])).toMatch(/exif\?dir=/)
    spy.mockRestore()
  })

  it('search like and collections', async () => {
    let spy = mockFetch({ results: [] })
    await apiSearchLike('/d', '/a.jpg', 'local', 10)
    expect(String(spy.mock.calls[0][0])).toMatch(/search_like$/)
    spy.mockRestore()
    spy = mockFetch({ collections: {} })
    await apiGetCollections('/d')
    expect(String(spy.mock.calls[0][0])).toMatch(/collections\?dir=/)
    spy.mockRestore()
    spy = mockFetch({ ok: true, collections: {} })
    await apiSetCollection('/d', 'C', ['/a.jpg'])
    expect(String(spy.mock.calls[0][0])).toMatch(/collections$/)
    spy.mockRestore()
    spy = mockFetch({ ok: true, deleted: 'C' })
    await apiDeleteCollection('/d', 'C')
    expect(String(spy.mock.calls[0][0])).toMatch(/collections\/delete$/)
    spy.mockRestore()
  })

  it('workspace list/add/remove and search workspace', async () => {
    let spy = mockFetch({ folders: [] })
    await apiWorkspaceList()
    expect(String(spy.mock.calls[0][0])).toMatch(/\/workspace$/)
    spy.mockRestore()
    spy = mockFetch({ folders: [] })
    await apiWorkspaceAdd('/p')
    expect(String(spy.mock.calls[0][0])).toMatch(/\/workspace\/add$/)
    spy.mockRestore()
    spy = mockFetch({ folders: [] })
    await apiWorkspaceRemove('/p')
    expect(String(spy.mock.calls[0][0])).toMatch(/\/workspace\/remove$/)
    spy.mockRestore()
    spy = mockFetch({ search_id: 's', results: [] })
    await apiSearchWorkspace('/d', 'q', 'local', 12, { favoritesOnly: true })
    expect(String(spy.mock.calls[0][0])).toMatch(/search_workspace$/)
    spy.mockRestore()
  })
})

